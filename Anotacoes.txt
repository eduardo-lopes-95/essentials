Ch2
constantes 
	são valores que não são alterados durante o programa
	podem ser usados na main, em outras funções, escopo global
	são declaradas com a keyword static
	nomes devem ser em letras maiusculas
	nomes separadas por underline caso sejam composto
	compilador não infere o tipo, portanto é preciso declarar um tipo

Tipos de dados
	Caracteres são valores unicode que ocupam 4 bytes de memória
	Vazio ou () -> valor unitário, equivalente ao null em outras linguagens
	bingind = receber
	(_) underline é usado para evitar avisos de que uma variável não esta sendo usada
	variáveis em rust são imutáveis
	mut (mutavel) = permite que uma variável tenha seu valor alterado
	let n = 42u8 / 42_u8 -> n recebe (binding) valor 42 do tipo using de 8 bit
	//let p12 = p1 + p2; não é possível concatenar referência de memória 
	let _p12 = p1.to_string() + p2;
	let p3 = format!("{} {}", p1, p2); 
	é possível fazer casting (conversões) com "as"
	alias (apelido) é possível com type. Ex: type magic = u16;
	
	rust é uma linguagem orientada a expressões, que são partes de código, como funções ou blocos {},
	(observação!!! no caso de funções com retorno tipado,
	temos dois tipos de saída: return algo; | algo 
	>>>> a 1ª forma não é um idiomatic code (jeito que a linguagem faz algo))

	Um bloco de código é uma expressão que retorna o *valor da última expressão*
	caso for otimido o ponto e virgula (;), caso seja inserido, o retorno será vazio/()

	& referencia o endereço de memória de onde algo esta guardado, ou seja, é um ponteiro
	
	valores na stack podem ser alocados na heap

--------------------------------------------------------------------------------------------------------

Ch3

if, if else, if let
	rust não tem o recurso de ternário
	alternativa: let age = if adult {"+18"} else {"-18"};

looping
	while
	loop
	for in

function
	em Rust não há problemas em colocar outras funções antes ou depois do main,
	porém é mais legível coloca-lá no topo do código.
	após -> é especificado o tipo de retorno de uma função
	o retorno de uma função é o valor da ultima expressão
	se você tiver mais de um valor para retornar, coloque dentro de uma tupla
	funções tem tipo. Ex: fn foo(i32) -> i32

attributes
	#[...] -> representam metadados sobre o código. 
	Ex: 
	*** podem evitar avisos
		#[warn(unused_variables)]

	*** ativar recursos de compilação

	*** benchmark code
		#[bench]

	*** compilação condicional
		ativar/desativar funções em S.O diferentes 
		#[cfg(target_os = "windows")]

	*** unit test
		#[test]

teste
	para rodar teste em Rust precisamos rodar no console `cargo test` onde o compilador vai procurar
	pelo atributo #[test] no código.
	Utilize asserts para testar o código:
		assert_eq!(actual, expect); o valor atual é igual ao esperado? 
		assert!(bool); a condição é verdadeira ou falsa? 2+3 == 5 ? true
	
	como podemos testar a falha do código?
	#[should_panic(expect = "assertion failed")]
	onde panic significa crash (quebra)
	#[test]
	#[should_panic(expected = "assertion failed")]
	fn failing_test() {
		assert!(6 == 2 + 3);
	}

	como podemos desabilitar um test?
	só colocar o atributo #[ignore]
	#[test]
	#[ignore]
	fn foo() {
		assert!(2 + 3 == 6);
	}

testar com cargo
	Qual a diferença entre lib e bin em rust? 
	
	bin é um projeto executável que contém a função main, roda através do comando cargo run
	
	lib não é um projeto executável pois contém um template de teste, roda através do comando cargo test
	
	rodar um teste -> cargo test nome_teste
	
	rodar todos os testes -> cargo test
	
	caso algum teste dependa de outro é interessante rodá-los dentro de uma mesma thread, para isso
	utilize -> cargo test -- -test-threads=1

	Modulos de teste
		testes são separados em dois tipos de aplicações:
			*** Testes unitários são escritos no modulo test no arquivo tests.rs na pasta src
			*** Teste de integração são escritos no arquivo lib.rs na pasta tests

			>> a função que vai passar pelo teste unitário fica no caminho src\lib.rs
			>> o teste unitário fica no caminho src\tests.rs
			>> o teste de integração fica no caminho tests\lib.rs
			
			Como chamar as funções da aplicação para realizar testes unitários?
			use super::*;

			Testes unitários estão contidos em módulos de test (mod test)

Ch4
	String
		Existem dois tipos de strings em Rust:
			>> string slice (&str) 
				>>> onde & é a referência para uma string
				>>> são imutáveis
				>>> tamanho fixo
					let nome1 = "Merlin";
					let nome2: &str = "Gandalf";
			
				string literal = 
					>>> armazenada diretamente no executável do programa, ou seja, é uma constante global
					>>> tem o tempo de vida da aplicação
						let nome3: &'static str = "Aragorn";
			
			>> String (buffer)
				>>> é o conjunto de caracters em si
				>>> são mutáveis
				>>> tamanho variádo
				>>> são armazenadas na Heap
				>>> toda vez que ela cresce, precisa ser realocada
					let mut str1 = String::new();

			>> Converter de slice string (&str) para String?
				>>> Utilize a função to_string()
					Ex: let mut str3 = nome1.to_string();

			>> String slice pode ser criada com a notação de range (..).
					Ex: let nome1 = "Merlin";
						let nome1_slice = &nome1[1..=2] //Mer
				
			>> Como percorrer caracter por caracter?
				>>> Utilize a função chars()
					Ex: let nome2 = "Aragorn";
						for c in nome2.chars(){
							print!("{} ",c)
						}
			>> Como adicionar sequencia de caracteres?
				>>> Utilize o método push()
					let mut str6 = String::new(); //String vazia
    				str6.push_str("Legolas"); //
					println!("{}", str6) //Legolas
			
			>> Como adicionar caracteres?
				>>> Utilize o método push()
					Ex: str6.push('s');
					println!("{}", str6) //Legolass
			
			>> Sempre que uma string for receber uma string como parametro, declare como string slice,
			   assim não precisaremos alocar na heap.
			   Ex: fn foo(s : &str) -> usize {s.len()}

			>> Como converter números em string? 
				>>> Utilize from_str
						let number1: f64 = f64::from_str("3.6")); //Ok(3.6)
					Ex: let number2: f64 = f64::from_str("3.7").unwrap(); //3.7
					O unwrap serve para acessar o conteúdo do Result (Ok)

	Array
		>> Declarando um array vazio
			Ex: let mut empty: [i32; 0] = [];
    			println!("{:?}", empty); //[]
			
		>> Declarando um array de 10 posições preenchido com zeros
			Ex: let mut empty: [i32; 10] = [0; 10]; 
				//Crie um vetor que aceite valores do tipo i32, contendo 10 posições = preenche 10 posições com 0
    			println!("{:?}", empty); //[]

		>> Acessar o tamanho do array: arr.len()
		>> Acessar a ultima posição: arr.len() - 1; 

	Vetores
		>> Há duas maneiras de declarar vetores:
			
			>>> new::()
				Ex: let mut numbers: Vec<i32> = Vec::new();
			
			>>> vec!
    			Ex: let mut magic_numbers = vec!(7i32, 42, 47, 45, 54);
			
		>>> Contruindo vetores a partir de range:
			Ex: let rgvec: Vec<i32> = (0..7).collect();
    			println!("{:?}", rgvec); //[0, 1, 2, 3, 4, 5, 6]
				Método collect serve para construir a coleção

	Higher order function 
		>>> função que recebe uma outra função como parâmetro
			pub fn again< F: Fn(i32) -> i32> (f: F, s:i32) -> i32 { f(f(s))}
			F: Fn(i32) -> i32, F é um tipo função (Fn) que recebe i32 como parâmetro, por fim, F retorna um i32

	Função Anonima
		>>> let triplo = |n| {3 * n};

	Iteradores
		>>> são objetos que retornam os itens de uma coleção em uma sequencia
		>>> são lazy por natureza, ou seja, chamado por necessidade, não geram valor a menos que sejam chamados
			let mut rng = 0..=7;
    		println!("> {:?}", rng.next());

			.iter() itera sobre um array/vetor
			
			&nome_variavel_iteradora = serve como iterador
				>>Muito mais performatico e seguro do que usar indexação.
			
			.iter().rev() inverte a ordem

	Consumers and adapters
		>>> iteradores são lazy (call-by-need) e tem que ser ativados pela invocação de quem vai consumí-los
		>>> find() = retornar o 1º valor que valida uma condição, o resultado é encapsulado por um option
		>>> filter() = retorna uma nova coleção de iteraveis a partir da coleção antiga
		>>> map() = cria um novo iterável a partir do original passando por todos os elementos
		>>> take(x) = pega x quantidade de algo																																																																																																																																
		>>> fold() = chamado de reduce ou inject, tem por objetivo reduzir a quantidade de dados
					 Necessita de dois parametros = um valor inicial e uma clojure com dois argumentos: acumulador e os elementos
					 let sum = (0..10).fold(0, |sum, n| sum + n);

	

https://nickymeuleman.netlify.app/garden/rust-expression-statement